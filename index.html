<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vietnam Check-in Map Treasury</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Leaflet CSS for Map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/SVRQLyT37WHaWfG08=" crossorigin=""/>
    <!-- Load Leaflet Marker Cluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

    <style>
        /* Custom styles */
        .list-container::-webkit-scrollbar { width: 6px; }
        .list-container::-webkit-scrollbar-thumb { background-color: #a8a29e; border-radius: 3px; }
        .list-container::-webkit-scrollbar-track { background-color: #f5f5f5; }

        /* Define style for the preview card (Tooltip) */
        #preview-card {
            position: fixed;
            top: 0;
            left: 0;
            width: 320px; /* Fixed width */
            z-index: 100;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        /* Map specific styles */
        #vietnam-map {
            height: 400px; /* Map height */
            width: 100%;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            margin-bottom: 2rem;
            z-index: 1; /* Keep map layer below preview card if needed */
        }

        @media (max-width: 768px) {
            #preview-card { display: none !important; }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans p-4 sm:p-8">

    <div id="app" class="max-w-4xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-indigo-700 mb-2">
                Vietnam Travel Treasury
            </h1>
            <p class="text-gray-600 text-lg">Hover over a location to see a quick summary.</p>
        </header>

        <!-- MAP CONTAINER (New requirement) -->
        <h2 class="text-2xl font-bold text-gray-800 mb-3 text-center">
             üìç B·∫£n ƒë·ªì ƒê·ªãa ƒëi·ªÉm Check-in "S·ªëng ·∫¢o" t·∫°i Vi·ªát Nam üáªüá≥
        </h2>
        <div id="vietnam-map"></div>
        <!-- End Map Container -->

        <!-- Search bar and filter (Existing functionalities) -->
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg mb-8 space-y-4 md:flex md:space-y-0 md:space-x-4">
            <!-- Search Input -->
            <input 
                type="text" 
                id="search-input" 
                placeholder="Search by location name..."
                class="w-full md:flex-1 p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
            >
            <!-- City Filter -->
            <select 
                id="city-filter" 
                class="w-full md:w-1/3 p-3 border border-gray-300 rounded-lg bg-white appearance-none focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                onchange="filterLocations()"
            >
                <option value="">-- Filter by City/Province --</option>
            </select>
        </div>

        <!-- Container for the list of locations (Existing functionalities) -->
        <div 
            id="location-list" 
            class="list-container grid gap-4 md:grid-cols-2 lg:grid-cols-3 max-h-[70vh] overflow-y-auto pr-2"
        >
            <!-- Locations will be rendered here -->
            <p id="loading-message" class="col-span-full text-center text-gray-500 p-8">Loading data...</p>
        </div>

        <footer class="mt-10 text-center text-gray-500 text-sm border-t pt-4">
            &copy; 2025 Tourism Data. Summarized data provided by Gemini API & Google Search. Map powered by Leaflet.
        </footer>
    </div>
    
    <!-- PREVIEW CARD (Existing functionalities) -->
    <div id="preview-card" class="hidden bg-white rounded-xl shadow-2xl p-4 border-t-4 border-indigo-500 transition-all duration-300">
        <div class="text-sm font-bold text-indigo-600 mb-2" id="preview-title"></div>
        <div id="preview-content" class="text-gray-700 text-sm leading-snug"></div>
        
        <div id="preview-loading" class="text-center py-4 hidden">
            <svg class="animate-spin h-5 w-5 text-indigo-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-1 text-sm text-gray-500">Searching for information...</p>
        </div>
    </div>

    <!-- Load Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20n6n+ByMhPIeZnhL6oYJbL1P5S3V3sB3t1Q2v5G5+0=" crossorigin=""></script>
    <!-- Load Leaflet Marker Cluster JS -->
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <script>
        // Initial Data (Added Lat/Lng for map integration)
        const rawLocations = [
            {"name": "Old Quarter (Ph·ªë C·ªï)", "address": "Hoan Kiem District, Hanoi", "lat": 21.0313, "lng": 105.8516},
            {"name": "Hoan Kiem Lake (H·ªì G∆∞∆°m)", "address": "Hoan Kiem District, Hanoi", "lat": 21.0287, "lng": 105.8522},
            {"name": "Long Bien Bridge (C·∫ßu Long Bi√™n)", "address": "Connecting Long Bien and Ba Dinh Districts, Hanoi", "lat": 21.0500, "lng": 105.8620},
            {"name": "Train Street (Ph·ªë ƒê∆∞·ªùng T√†u)", "address": "Ba Dinh District, Hanoi", "lat": 21.0260, "lng": 105.8450},
            {"name": "Ha Long Bay (V·ªãnh H·∫° Long)", "address": "Ha Long City, Quang Ninh", "lat": 20.8710, "lng": 107.0350},
            {"name": "Trang An Ecotourism (Khu du l·ªãch Tr√†ng An)", "address": "Gia Vien District, Ninh Binh", "lat": 20.2642, "lng": 105.9031},
            {"name": "Sapa Terraces (Ru·ªông b·∫≠c thang Sa Pa)", "address": "Sapa, Lao Cai", "lat": 22.3390, "lng": 103.8500},
            {"name": "Ba Vi National Park (V∆∞·ªùn Qu·ªëc gia Ba V√¨)", "address": "Ba Vi, Hanoi", "lat": 21.0350, "lng": 105.3700},
            
            {"name": "Golden Bridge (C·∫ßu V√†ng), Ba Na Hills", "address": "Hoa Vang District, Da Nang", "lat": 16.0123, "lng": 108.0680},
            {"name": "Dragon Bridge (C·∫ßu R·ªìng)", "address": "Hai Chau District, Da Nang", "lat": 16.0645, "lng": 108.2210},
            {"name": "Hoi An Ancient Town (Ph·ªë c·ªï H·ªôi An)", "address": "Minh An Ward, Hoi An City, Quang Nam", "lat": 15.8794, "lng": 108.3360},
            {"name": "My Khe Beach (B√£i bi·ªÉn M·ªπ Kh√™)", "address": "Son Tra District, Da Nang", "lat": 16.0689, "lng": 108.2435},
            {"name": "Marble Mountains (Ng≈© H√†nh S∆°n)", "address": "Ngu Hanh Son District, Da Nang", "lat": 16.0076, "lng": 108.2831},
            {"name": "Hai Van Pass (ƒê√®o H·∫£i V√¢n)", "address": "Border of Hue and Da Nang", "lat": 16.1950, "lng": 108.0400},
            {"name": "Thien Mu Pagoda (Ch√πa Thi√™n M·ª•)", "address": "Hue", "lat": 16.4560, "lng": 107.5500},
            {"name": "Ly Son Island (ƒê·∫£o L√Ω S∆°n)", "address": "Quang Ngai", "lat": 15.3780, "lng": 109.1100},

            {"name": "Notre-Dame Cathedral (Nh√† th·ªù ƒê·ª©c B√† S√†i G√≤n)", "address": "District 1, Ho Chi Minh City", "lat": 10.7797, "lng": 106.6990},
            {"name": "Ben Thanh Market (Ch·ª£ B·∫øn Th√†nh)", "address": "District 1, Ho Chi Minh City", "lat": 10.7725, "lng": 106.6980},
            {"name": "Bitexco Financial Tower", "address": "District 1, Ho Chi Minh City", "lat": 10.7716, "lng": 106.7032},
            {"name": "Nguyen Hue Walking Street (Ph·ªë ƒëi b·ªô Nguy·ªÖn Hu·ªá)", "address": "District 1, Ho Chi Minh City", "lat": 10.7735, "lng": 106.7025},
            {"name": "Crazy House (Bi·ªát th·ª± H·∫±ng Nga)", "address": "Da Lat, Lam Dong", "lat": 11.9390, "lng": 108.4370},
            {"name": "Xuan Huong Lake (H·ªì Xu√¢n H∆∞∆°ng)", "address": "City Center, Da Lat, Lam Dong", "lat": 11.9427, "lng": 108.4419},
            {"name": "Bai Sao Beach (B√£i Sao)", "address": "Phu Quoc Island, Kien Giang", "lat": 10.0460, "lng": 104.0480},
            {"name": "Dinh Cau Night Market (Ch·ª£ ƒë√™m Dinh C·∫≠u)", "address": "Phu Quoc, Kien Giang", "lat": 10.2240, "lng": 103.9570},
            {"name": "Cai Rang Floating Market (Ch·ª£ n·ªïi C√°i RƒÉng)", "address": "Can Tho", "lat": 10.0075, "lng": 105.7483},
            {"name": "Mui Ne Beach (B√£i bi·ªÉn M≈©i N√©)", "address": "Binh Thuan", "lat": 10.9300, "lng": 108.2000},
            {"name": "Ho Tram Beach (B√£i bi·ªÉn H·ªì Tr√†m)", "address": "Ba Ria - Vung Tau", "lat": 10.5180, "lng": 107.4120}
        ];

        // --- JAVASCRIPT & GEMINI API LOGIC AREA ---

        const locationListElement = document.getElementById('location-list');
        const searchInputElement = document.getElementById('search-input');
        const cityFilterElement = document.getElementById('city-filter');
        const previewCard = document.getElementById('preview-card');
        const previewTitle = document.getElementById('preview-title');
        const previewContent = document.getElementById('preview-content');
        const previewLoading = document.getElementById('preview-loading');

        // Map variables
        let vietnamMap;
        let markerClusterGroup;
        let mapMarkers = [];

        // Cache and API Configuration
        const previewCache = {};
        const GEMINI_MODEL = "gemini-2.5-flash-preview-05-20";
        const GEMINI_API_KEY = "";
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        
        // --- INITIAL DATA PROCESSING LOGIC ---

        function extractCity(address) {
            if (!address) return "Other";
            if (address.includes("Ho Chi Minh City") || address.includes("HCM")) return "Ho Chi Minh City";
            if (address.includes("Hanoi") || address.includes("H√† N·ªôi")) return "Hanoi";
            if (address.includes("Quang Nam")) return "Quang Nam (Hoi An)";
            if (address.includes("Da Nang") || address.includes("ƒê√† N·∫µng")) return "Da Nang";
            if (address.includes("Quang Ninh")) return "Quang Ninh (Ha Long)";
            if (address.includes("Lao Cai") || address.includes("L√†o Cai")) return "Lao Cai (Sapa)";
            if (address.includes("Ninh Binh") || address.includes("Ninh B√¨nh")) return "Ninh Binh";
            if (address.includes("Kien Giang") || address.includes("Ki√™n Giang")) return "Kien Giang (Phu Quoc)";
            if (address.includes("Lam Dong") || address.includes("L√¢m ƒê·ªìng") || address.includes("Da Lat")) return "Lam Dong (Da Lat)";
            if (address.includes("Hue") || address.includes("Hu·∫ø")) return "Thua Thien Hue";
            const parts = address.split(',').map(p => p.trim());
            return parts[parts.length - 1] || "Other";
        }

        const locations = rawLocations.map(loc => ({
            ...loc,
            city: extractCity(loc.address),
            // Determine region based on latitude (simple approximation for visualization)
            region: loc.lat > 20 ? 'North' : (loc.lat > 15 ? 'Central' : 'South')
        }));

        function populateCityFilter() {
            const cities = new Set(locations.map(loc => loc.city).filter(c => c));
            const priorityCities = ["Hanoi", "Ho Chi Minh City", "Da Nang", "Quang Nam (Hoi An)", "Lam Dong (Da Lat)", "Kien Giang (Phu Quoc)", "Quang Ninh (Ha Long)", "Ninh Binh", "Thua Thien Hue"];
            const sortedCities = Array.from(cities).sort((a, b) => {
                const aIndex = priorityCities.indexOf(a);
                const bIndex = priorityCities.indexOf(b);
                if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
                if (aIndex !== -1 && bIndex === -1) return -1;
                if (aIndex === -1 && bIndex !== -1) return 1;
                return aIndex - bIndex;
            });
            
            sortedCities.forEach(city => {
                const option = document.createElement('option');
                option.value = city;
                option.textContent = city;
                cityFilterElement.appendChild(option);
            });
        }

        // --- MAP INITIALIZATION AND RENDERING ---

        function initMap() {
            // Initialize map centered roughly on Vietnam
            vietnamMap = L.map('vietnam-map', {
                center: [16.0, 107.8], // Central Vietnam
                zoom: 5,
                minZoom: 5,
                maxZoom: 18,
                zoomControl: true 
            });

            // Add tile layer (OpenStreetMap)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(vietnamMap);

            // Initialize marker cluster group
            markerClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                spiderfyOnMaxZoom: true // Cluster functionality
            });
            vietnamMap.addLayer(markerClusterGroup);
        }

        function updateMapMarkers(filteredList) {
            // 1. Clear existing markers
            markerClusterGroup.clearLayers();
            mapMarkers = [];

            // 2. Add markers for filtered locations
            filteredList.forEach(loc => {
                if (loc.lat && loc.lng) {
                    // Create tooltip content
                    const tooltipContent = `
                        <div class="font-bold text-indigo-700">${loc.name}</div>
                        <div class="text-xs text-gray-600">${loc.address}</div>
                    `;

                    // Simple icon based on region (North: Blue, Central: Green, South: Red)
                    let markerColor;
                    if (loc.region === 'North') markerColor = '#1d4ed8'; // blue-700
                    else if (loc.region === 'Central') markerColor = '#059669'; // emerald-600
                    else markerColor = '#dc2626'; // red-600

                    const customIcon = L.divIcon({
                        className: 'custom-div-icon',
                        html: `<div style="background-color: ${markerColor}; width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>`,
                        iconSize: [14, 14],
                        iconAnchor: [7, 7]
                    });

                    const marker = L.marker([loc.lat, loc.lng], { icon: customIcon })
                        .bindTooltip(tooltipContent, {
                            permanent: false,
                            direction: 'top',
                            offset: [0, -10]
                        });
                    
                    marker.locationData = loc; // Store location data for filtering
                    markerClusterGroup.addLayer(marker);
                    mapMarkers.push(marker);
                }
            });
        }

        // --- PREVIEW & API CALL LOGIC (Existing functionality) ---
        
        // Function to fetch API with exponential backoff
        async function retryFetch(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429 && i < maxRetries - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    console.error("Fetch failed, retrying...", error); 
                }
            }
        }


        // Main function to call Gemini API for Google Search summary
        async function fetchGoogleSearchPreview(locationName) {
            if (previewCache[locationName]) {
                return previewCache[locationName];
            }

            // Prompt Configuration (English output, strictly 5-10 lines)
            const systemPrompt = "Act as a professional travel guide. Provide a concise, single-paragraph summary of this tourist location in English, strictly limited to 5-10 lines. Focus on key highlights, history, or recent travel experiences. Do not mention phrases like 'based on search' or 'I found'.";
            const userQuery = `Find the latest information and briefly summarize ${locationName} in Vietnam. Provide the output in English, ensuring it is no more than 10 lines long.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            try {
                const response = await retryFetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const text = candidate.content.parts[0].text;
                    const data = { text, error: null };
                    previewCache[locationName] = data;
                    return data;

                } else {
                    const errorMsg = "Could not generate summary. Please try again.";
                    previewCache[locationName] = { text: errorMsg, error: true };
                    return previewCache[locationName];
                }

            } catch (error) {
                console.error("Gemini API Error:", error);
                const errorMsg = "Connection error. Please check the console or try again.";
                previewCache[locationName] = { text: errorMsg, error: true };
                return previewCache[locationName];
            }
        }

        // Function to update the preview card
        function updatePreviewCard(locationName, result) {
            previewTitle.textContent = locationName;
            
            if (result.error) {
                 previewContent.innerHTML = `<p class="text-red-500">Error: ${result.text}</p>`;
            } else {
                 previewContent.innerHTML = result.text.replace(/\n/g, '<br>');
            }
            
            previewLoading.classList.add('hidden');
            previewContent.classList.remove('hidden');
        }

        // Function to handle mouse enter event (Existing functionality)
        async function handleMouseEnter(event) {
            if (window.innerWidth <= 768) return; 

            const target = event.currentTarget;
            const locationName = target.getAttribute('data-name');

            const rect = target.getBoundingClientRect();
            
            let cardX = rect.right + 20; 
            let cardY = rect.top + window.scrollY; 
            
            if (cardX + 320 > window.innerWidth - 20) {
                cardX = rect.left - 320 - 20;
            }
            
            if (cardX < 20) {
                 cardX = rect.right + 20; 
            }

            previewCard.style.left = `${cardX}px`;
            previewCard.style.top = `${cardY}px`;
            previewCard.classList.remove('hidden');
            previewCard.style.opacity = '1';

            previewTitle.textContent = locationName;
            previewLoading.classList.remove('hidden');
            previewContent.classList.add('hidden');
            
            try {
                const result = await fetchGoogleSearchPreview(locationName);
                if (locationListElement.contains(target)) { 
                    updatePreviewCard(locationName, result);
                }
            } catch(e) {
                 if (locationListElement.contains(target)) {
                    updatePreviewCard(locationName, { text: "An error occurred while loading data.", error: true });
                }
            }
        }

        // Function to handle mouse leave event (Existing functionality)
        function handleMouseLeave() {
            previewCard.classList.add('hidden');
            previewCard.style.opacity = '0';
        }

        // --- RENDER & FILTER LOGIC (Updated to include map updates) ---

        function renderLocations(filteredList) {
            locationListElement.innerHTML = '';
            
            if (filteredList.length === 0) {
                locationListElement.innerHTML = '<p class="col-span-full text-center text-xl text-red-500 font-medium p-10 bg-yellow-50 rounded-xl shadow-inner">No locations found matching the search/filter criteria.</p>';
                return;
            }

            filteredList.forEach(loc => {
                const item = document.createElement('div');
                item.className = 'loc-card bg-white p-4 rounded-xl shadow-md hover:shadow-xl transition-all duration-300 transform hover:scale-[1.02] border border-gray-100 cursor-pointer';
                item.setAttribute('data-name', loc.name);
                
                // Attach mouse events
                item.addEventListener('mouseenter', handleMouseEnter);
                item.addEventListener('mouseleave', handleMouseLeave);
                
                // Add click listener to center map on the location
                item.addEventListener('click', () => {
                    if (loc.lat && loc.lng) {
                        vietnamMap.setView([loc.lat, loc.lng], 12);
                    }
                });


                const icon = loc.city.includes("Hanoi") || loc.city.includes("Hue") ? 'üèõÔ∏è' : 
                             loc.city.includes("Ho Chi Minh City") ? 'üèôÔ∏è' : 
                             loc.city.includes("Da Nang") || loc.city.includes("Quang Nam") ? '‚õ±Ô∏è' :
                             loc.city.includes("Phu Quoc") ? 'üèùÔ∏è' :
                             loc.city.includes("Da Lat") ? '‚õ∞Ô∏è' : 'üáªüá≥';

                item.innerHTML = `
                    <div class="flex items-center space-x-3 mb-2">
                        <span class="text-2xl">${icon}</span>
                        <h2 class="text-lg font-semibold text-indigo-600 leading-tight">${loc.name}</h2>
                    </div>
                    <p class="text-xs font-medium text-gray-500 bg-indigo-50 inline-block px-2 py-0.5 rounded-full mb-2">
                        ${loc.city} (${loc.region})
                    </p>
                    <p class="text-sm text-gray-700 mt-1">
                        <span class="font-medium text-gray-500">Address:</span> ${loc.address}
                    </p>
                `;
                locationListElement.appendChild(item);
            });
            
            // Update the map markers based on the filtered list
            updateMapMarkers(filteredList);
        }

        function filterLocations() {
            const searchTerm = searchInputElement.value.toLowerCase().trim();
            const selectedCity = cityFilterElement.value;

            const filtered = locations.filter(loc => {
                const matchesSearch = loc.name.toLowerCase().includes(searchTerm) || 
                                      loc.address.toLowerCase().includes(searchTerm);
                
                const matchesCity = !selectedCity || loc.city === selectedCity;

                return matchesSearch && matchesCity;
            });

            renderLocations(filtered);
        }

        // --- INITIALIZATION ---

        searchInputElement.addEventListener('input', filterLocations);

        window.onload = () => {
            document.getElementById('loading-message').style.display = 'none'; 
            initMap(); // Initialize the map first
            populateCityFilter();
            renderLocations(locations); // Render locations and populate map
        };
    </script>
</body>
</html>
